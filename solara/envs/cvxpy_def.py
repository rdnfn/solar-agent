"""CVXPY problem definition from battery control env."""
import cvxpy as cp
import numpy as np
from solara.constants import PROJECT_PATH
import solara.envs.battery_control


def create_cvxpy_def(
    # pylint: disable=unused-argument, invalid-name
    battery_control_env: solara.envs.battery_control.BatteryControlEnv,
):
    """Create CVXPY definition corresponding to problem represented in environment.

    Args:
        battery_control_env (solara.envs.battery_control.BatteryControlEnv): RL
            environment to create definition for.
    """

    load_data = np.loadtxt(
        PROJECT_PATH + "/data/ausgrid/processed/house2_combined_load.txt", delimiter=","
    )
    pv_data = np.loadtxt(
        PROJECT_PATH + "/data/ausgrid/processed/house2_solar_gen.txt", delimiter=","
    )

    #############
    # VARIABLES #
    #############

    # Given variables #
    ###################

    # Basic
    T_u = 1  # Time slot duration
    T_h = 24  # Time horizon (hours)

    # Grid
    pi_b = 0.14  # 0.14 # Base price per unit of energy purchased ($/kWh)
    pi_d = 0.86  # Demand price penalty per unit of energy purchased with power demand
    # ... exceeding Γ($/kWh)
    Gamma = 1.00  # np.percentile(load_data, 80) # Threshold above which the demand
    # ... price is paid (kW)
    p_bar = 0.12  # Price per unit of energy sold at time t ($/kWh)

    # Battery variables
    size = 10
    kWh_per_cell = 0.011284
    num_cells = size / kWh_per_cell

    nominal_voltage_c = 3.8793
    nominal_voltage_d = 3.5967
    u1 = 0.1920
    v1_bar = 0.0
    u2 = -0.4865
    v2_bar = kWh_per_cell * num_cells
    eta_d = 1 / 0.9  # taking reciprocal so that we don't divide by eta_d
    eta_c = 0.9942
    alpha_bar_d = v2_bar * 1  # the 1 indicates the maximum discharging C-rate
    alpha_bar_c = v2_bar * 1  # the 1 indicates the maximum charging C-rate

    # Given variables from data set
    num_timesteps = T_h
    start = 24 * 200
    power_load = load_data[
        start : (start + num_timesteps)
    ]  # np.random.randn(num_timesteps) # Load at time t (kW)
    power_solar = pv_data[
        start : start + num_timesteps
    ]  # np.random.randn(num_timesteps) # Power generated by solar panels at timet(kW)

    # Variables that are being optimised over
    power_direct = cp.Variable(
        num_timesteps
    )  # Power flowing directly from PV and grid to meet the load or be sold at
    # time t (kW) (P_dir)
    power_charge = cp.Variable(
        num_timesteps
    )  # Power used to charge the ESD at time t (kW) (P_c)
    power_discharge = cp.Variable(
        num_timesteps
    )  # Power from the ESD at time t (kW) (P_d)
    power_grid = cp.Variable(
        num_timesteps
    )  # Power drawn from the grid at time t (kW) (P_g)
    power_sell = cp.Variable(
        num_timesteps
    )  # Power sold to the grid at timet(kW) (P_sell)
    power_over_thres = cp.Variable(
        num_timesteps
    )  # Purchased power that exceeds Γ at time t (not in notation table) (P_over)

    # Implicitly defined variable (not in paper in "given" or "optimized over"
    # set of variables)
    energy_battery = cp.Variable(
        num_timesteps + 1
    )  # the  energy  content  of  the  ESD  at  the  beginning  of  interval t (E_ESD)

    variables = [
        T_u,
        T_h,
        pi_b,
        pi_d,
        Gamma,
        p_bar,
        size,
        kWh_per_cell,
        num_cells,
        nominal_voltage_c,
        nominal_voltage_d,
        u1,
        v1_bar,
        u2,
        v2_bar,
        eta_d,
        eta_c,
        alpha_bar_d,
        alpha_bar_c,
        num_timesteps,
        start,
        power_load,
        power_solar,
        power_direct,
        power_charge,
        power_discharge,
        power_grid,
        num_timesteps,
        power_sell,
        power_over_thres,
        energy_battery,
    ]

    ###############
    # CONSTRAINTS #
    ###############

    base_constraints = [
        0 <= power_grid,  # from Equation (13)
        0 <= power_direct,
        0 <= power_sell,
        0 <= power_charge,  # Eq (18)
        0 <= power_discharge,  # Eq  (19)
        # Power flow
        power_direct + power_discharge == power_load + power_sell,  # from Equation (14)
        0 <= power_charge + power_direct,  # Eq (17)
        power_charge + power_direct <= power_solar + power_grid,  # Eq (17)
    ]

    grid_constraints = [
        0 <= power_over_thres,
        power_grid - Gamma <= power_over_thres,  # Eq (24)
        power_sell == 0,  # stopping selling to the grid
    ]

    battery_constraints = [
        energy_battery[0] == 0,
        energy_battery[1:]
        == energy_battery[:-1]
        + eta_c * power_charge * T_u
        - eta_d * power_discharge * T_u,
        energy_battery >= 0,
        power_discharge <= alpha_bar_d,
        power_charge <= alpha_bar_c,  # equation (5)
        u1 * ((power_discharge) / nominal_voltage_d) + v1_bar
        <= energy_battery[1:],  # equation (4)
        u2 * ((power_charge) / nominal_voltage_c) + v2_bar
        >= energy_battery[1:],  # equation (4)
    ]

    constraints = base_constraints + battery_constraints + grid_constraints

    objective = cp.Minimize(
        cp.sum(
            pi_b * power_grid + pi_d * power_over_thres - cp.multiply(p_bar, power_sell)
        )
    )

    # Note: these actions do not account for normalisation that may occur in RL env
    actions = [power_charge - power_discharge]

    cvxpy_def = {
        "variables": variables,
        "actions": actions,
        "constraints": constraints,
        "objective": objective,
    }

    return cvxpy_def
